<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シンプルなオセロゲーム</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            border: 2px solid #333;
            margin: 20px auto;
            background-color: #008000; /* オセロ盤の色 */
            box-shadow: 0 0 15px rgba(0, 128, 0, 0.5);
        }
        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid #005000;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-sizing: border-box; /* paddingやborderをwidth/heightに含める */
        }
        .cell.highlight {
            background-color: rgba(255, 255, 0, 0.3); /* 置ける場所のハイライト */
        }
        .disk {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: black;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .disk.white {
            background-color: white;
        }
        #status {
            margin-top: 10px;
            font-size: 1.2em;
            font-weight: bold;
        }
        #resetButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>シンプルなオセロゲーム</h1>
        <div id="status">黒の番です (黒: 2, 白: 2)</div>
        <div id="board"></div>
        <button id="resetButton">ゲームをリセット</button>
    </div>

    <script>
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;

        let board = [];
        let currentPlayer = BLACK;
        let gameOver = false;

        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');

        // ゲームの初期化
        function initializeGame() {
            board = Array(8).fill(0).map(() => Array(8).fill(EMPTY));
            board[3][3] = WHITE;
            board[3][4] = BLACK;
            board[4][3] = BLACK;
            board[4][4] = WHITE;
            currentPlayer = BLACK;
            gameOver = false;
            renderBoard();
            updateStatus();
            highlightValidMoves();
        }

        // 盤面の描画
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('click', handleCellClick);

                    if (board[r][c] === BLACK) {
                        const disk = document.createElement('div');
                        disk.classList.add('disk');
                        cell.appendChild(disk);
                    } else if (board[r][c] === WHITE) {
                        const disk = document.createElement('div');
                        disk.classList.add('disk', 'white');
                        cell.appendChild(disk);
                    }
                    boardElement.appendChild(cell);
                }
            }
        }

        // ステータスの更新
        function updateStatus() {
            const blackCount = board.flat().filter(disk => disk === BLACK).length;
            const whiteCount = board.flat().filter(disk => disk === WHITE).length;

            let statusText = '';
            if (gameOver) {
                if (blackCount > whiteCount) {
                    statusText = `ゲーム終了！ 黒の勝ちです (${blackCount} vs ${whiteCount})`;
                } else if (whiteCount > blackCount) {
                    statusText = `ゲーム終了！ 白の勝ちです (${blackCount} vs ${whiteCount})`;
                } else {
                    statusText = `ゲーム終了！ 引き分けです (${blackCount} vs ${whiteCount})`;
                }
            } else {
                statusText = `${currentPlayer === BLACK ? '黒' : '白'}の番です (黒: ${blackCount}, 白: ${whiteCount})`;
            }
            statusElement.textContent = statusText;
        }

        // 有効な手が存在するかチェック
        function isValidMove(row, col, player) {
            if (board[row][col] !== EMPTY) {
                return false;
            }

            const opponent = player === BLACK ? WHITE : BLACK;
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                let foundOpponent = false;

                while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
                    r += dr;
                    c += dc;
                    foundOpponent = true;
                }

                if (foundOpponent && r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player) {
                    return true;
                }
            }
            return false;
        }

        // 有効な手をハイライト表示
        function highlightValidMoves() {
            document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('highlight'));
            if (gameOver) return;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(r, c, currentPlayer)) {
                        const cellElement = boardElement.children[r * 8 + c];
                        cellElement.classList.add('highlight');
                    }
                }
            }
        }

        // 石をひっくり返す
        function flipDisks(row, col, player) {
            const opponent = player === BLACK ? WHITE : BLACK;
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
            let disksFlipped = 0;

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                const disksToFlip = [];

                while (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === opponent) {
                    disksToFlip.push([r, c]);
                    r += dr;
                    c += dc;
                }

                if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] === player) {
                    disksToFlip.forEach(([flipR, flipC]) => {
                        board[flipR][flipC] = player;
                        disksFlipped++;
                    });
                }
            }
            return disksFlipped;
        }

        // 手番を交代
        function switchPlayer() {
            currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
        }

        // 次のプレイヤーが手番をパスすべきかチェック
        function canCurrentPlayerMakeMove() {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(r, c, currentPlayer)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // ゲームの終了判定
        function checkGameOver() {
            const blackCanMove = canCurrentPlayerMakeMove(BLACK);
            switchPlayer(); // 仮に手番を交代して白の手番で動けるか確認
            const whiteCanMove = canCurrentPlayerMakeMove(WHITE);
            switchPlayer(); // 手番を元に戻す

            if (!blackCanMove && !whiteCanMove) {
                gameOver = true;
            }
        }

        // プレイヤーのクリックハンドラ
        function handleCellClick(event) {
            if (gameOver || currentPlayer === WHITE) { // CPUの番であればクリックを無視
                return;
            }

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            if (isValidMove(row, col, currentPlayer)) {
                board[row][col] = currentPlayer;
                flipDisks(row, col, currentPlayer);
                renderBoard();
                checkGameOver();
                updateStatus();
                if (!gameOver) {
                    switchPlayer();
                    highlightValidMoves();
                    // CPUの手番に移行
                    if (currentPlayer === WHITE) {
                        setTimeout(cpuMove, 1000); // 1秒後にCPUの手番を実行
                    }
                }
            } else {
                alert('そこには置けません！');
            }
        }

        // CPUの手番ロジック (シンプル版)
        function cpuMove() {
            if (gameOver || currentPlayer !== WHITE) {
                return;
            }

            const validMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(r, c, WHITE)) {
                        // シンプルなCPU: とりあえず置ける場所を候補に入れる
                        // ここでひっくり返せる石の数を数えるなどして、より賢いAIにすることも可能
                        validMoves.push({ row: r, col: c });
                    }
                }
            }

            if (validMoves.length > 0) {
                // 最もひっくり返せる石が多い手を選ぶ (少しだけ賢く)
                let bestMove = null;
                let maxFlipped = -1;

                for (const move of validMoves) {
                    // 一時的にボードをコピーして試行
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    tempBoard[move.row][move.col] = WHITE;
                    const flipped = calculateFlippedDisks(tempBoard, move.row, move.col, WHITE);

                    if (flipped > maxFlipped) {
                        maxFlipped = flipped;
                        bestMove = move;
                    }
                }

                board[bestMove.row][bestMove.col] = WHITE;
                flipDisks(bestMove.row, bestMove.col, WHITE);
                renderBoard();
                checkGameOver();
                updateStatus();
                if (!gameOver) {
                    switchPlayer();
                    highlightValidMoves();
                    // 黒が動けない場合、白が連続して動けるようにする
                    if (!canCurrentPlayerMakeMove()) {
                        setTimeout(cpuMove, 1000); // 再度CPUの手番
                    }
                }
            } else {
                // CPUが置ける場所がない場合
                alert('白は置ける場所がありません。パスします。');
                switchPlayer();
                highlightValidMoves();
                // もし黒も置けないならゲーム終了
                if (!canCurrentPlayerMakeMove()) {
                    checkGameOver(); // 両者パスならゲーム終了
                    updateStatus();
                }
            }
        }

        // 特定の位置に石を置いた場合にひっくり返る石の数を計算する (CPU用ヘルパー)
        function calculateFlippedDisks(tempBoard, row, col, player) {
            const opponent = player === BLACK ? WHITE : BLACK;
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
            let disksFlipped = 0;

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                const disksToFlip = [];

                while (r >= 0 && r < 8 && c >= 0 && c < 8 && tempBoard[r][c] === opponent) {
                    disksToFlip.push([r, c]);
                    r += dr;
                    c += dc;
                }

                if (r >= 0 && r < 8 && c >= 0 && c < 8 && tempBoard[r][c] === player) {
                    disksFlipped += disksToFlip.length;
                }
            }
            return disksFlipped;
        }

        // イベントリスナーの設定
        resetButton.addEventListener('click', initializeGame);

        // ゲーム開始
        initializeGame();

    </script>
</body>
</html>
