<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>単独HTML将棋ゲーム</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        #game-container {
            display: flex;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #shogi-board {
            display: grid;
            grid-template-columns: repeat(9, 60px);
            grid-template-rows: repeat(9, 60px);
            border: 2px solid #333;
            background-color: #f7e6c7; /* 将棋盤の色 */
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            width: 540px; /* 9 * 60px */
            height: 540px; /* 9 * 60px */
        }

        .square {
            width: 60px;
            height: 60px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
            user-select: none; /* テキスト選択を無効に */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .square.selected {
            background-color: #add8e6; /* LightBlue */
        }

        .square.movable {
            background-color: #90ee90; /* LightGreen */
        }

        .piece {
            font-weight: bold;
            color: #333;
            transform-origin: center;
            transition: transform 0.1s ease-out;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .piece.sente {
            color: #d12222; /* 先手駒の色 */
        }

        .piece.gote {
            transform: rotate(180deg);
            color: #2222d1; /* 後手駒の色 */
        }

        .piece.promoted {
            color: #d122d1; /* 成り駒の色 (紫) */
        }

        #info-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 200px;
            padding: 10px;
            background-color: #e9e9e9;
            border-radius: 5px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        #current-player {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
        }

        #status-message {
            min-height: 2em;
            text-align: center;
            color: #555;
        }

        #captured-pieces {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .captured-area {
            border: 1px solid #bbb;
            padding: 5px;
            border-radius: 4px;
            background-color: #fdfdfd;
            min-height: 80px;
        }

        .captured-pieces-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
        }

        .captured-piece {
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            padding: 3px 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: #fff;
        }
        .captured-piece.sente { color: #d12222; }
        .captured-piece.gote { color: #2222d1; transform: rotate(180deg); } /* 持ち駒も回転 */

        button {
            padding: 8px 15px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0056b3;
        }

        #ai-toggle {
            background-color: #28a745;
        }
        #ai-toggle:hover {
            background-color: #218838;
        }
        #ai-toggle.disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

    </style>
</head>
<body>
    <h1>単独HTML将棋ゲーム</h1>

    <div id="game-container">
        <div id="info-panel">
            <h3>後手の持ち駒</h3>
            <div id="gote-captured" class="captured-area">
                <div class="captured-pieces-list"></div>
            </div>
            <div id="current-player">現在の手番: 先手</div>
            <div id="status-message"></div>
            <button id="reset-button">リセット</button>
            <button id="ai-toggle">AI (CPU) 対戦を有効にする</button>
            <h3>先手の持ち駒</h3>
            <div id="sente-captured" class="captured-area">
                <div class="captured-pieces-list"></div>
            </div>
        </div>
        <div id="shogi-board"></div>
    </div>

    <script>
        const boardElement = document.getElementById('shogi-board');
        const currentPlayerElement = document.getElementById('current-player');
        const statusMessageElement = document.getElementById('status-message');
        const resetButton = document.getElementById('reset-button');
        const aiToggleButton = document.getElementById('ai-toggle');
        const senteCapturedElement = document.querySelector('#sente-captured .captured-pieces-list');
        const goteCapturedElement = document.querySelector('#gote-captured .captured-pieces-list');

        let board = []; // 9x9の盤面を表す配列
        let currentPlayer = 'sente'; // 'sente' (先手) or 'gote' (後手)
        let selectedSquare = null; // 選択中の駒があるマス
        let senteCaptured = []; // 先手の持ち駒
        let goteCaptured = []; // 後手の持ち駒
        let isAIEnabled = false; // AI対戦が有効か
        let isMoving = false; // 駒が動いている最中か (アニメーション用)

        // 駒の種類と表示文字、移動ルール、成りルール
        const PIECES = {
            '歩': { char: '歩', canPromote: true, promoteTo: 'と' },
            '香': { char: '香', canPromote: true, promoteTo: '成香' },
            '桂': { char: '桂', canPromote: true, promoteTo: '成桂' },
            '銀': { char: '銀', canPromote: true, promoteTo: '成銀' },
            '金': { char: '金', canPromote: false },
            '角': { char: '角', canPromote: true, promoteTo: '馬' },
            '飛': { char: '飛', canPromote: true, promoteTo: '龍' },
            '王': { char: '王', canPromote: false },
            'と': { char: 'と', canPromote: false },
            '成香': { char: '成香', canPromote: false },
            '成桂': { char: '成桂', canPromote: false },
            '成銀': { char: '成銀', canPromote: false },
            '馬': { char: '馬', canPromote: false },
            '龍': { char: '龍', canPromote: false }
        };

        // 成り駒の対応表 (key: 成る前の駒, value: 成り駒)
        const PROMOTED_MAP = {
            '歩': 'と', '香': '成香', '桂': '成桂', '銀': '成銀', '角': '馬', '飛': '龍'
        };

        // 駒の初期配置
        const initialBoard = [
            [{ type: '香', player: 'gote' }, { type: '桂', player: 'gote' }, { type: '銀', player: 'gote' }, { type: '金', player: 'gote' }, { type: '王', player: 'gote' }, { type: '金', player: 'gote' }, { type: '銀', player: 'gote' }, { type: '桂', player: 'gote' }, { type: '香', player: 'gote' }],
            [null, { type: '飛', player: 'gote' }, null, null, null, null, null, { type: '角', player: 'gote' }, null],
            [{ type: '歩', player: 'gote' }, { type: '歩', player: 'gote' }, { type: '歩', player: 'gote' }, { type: '歩', player: 'gote' }, { type: '歩', player: 'gote' }, { type: '歩', player: 'gote' }, { type: '歩', player: 'gote' }, { type: '歩', player: 'gote' }, { type: '歩', player: 'gote' }],
            [null, null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null, null],
            [{ type: '歩', player: 'sente' }, { type: '歩', player: 'sente' }, { type: '歩', player: 'sente' }, { type: '歩', player: 'sente' }, { type: '歩', player: 'sente' }, { type: '歩', player: 'sente' }, { type: '歩', player: 'sente' }, { type: '歩', player: 'sente' }, { type: '歩', player: 'sente' }],
            [null, { type: '角', player: 'sente' }, null, null, null, null, null, { type: '飛', player: 'sente' }, null],
            [{ type: '香', player: 'sente' }, { type: '桂', player: 'sente' }, { type: '銀', player: 'sente' }, { type: '金', player: 'sente' }, { type: '王', player: 'sente' }, { type: '金', player: 'sente' }, { type: '銀', player: 'sente' }, { type: '桂', player: 'sente' }, { type: '香', player: 'sente' }]
        ];

        // --- ゲームの初期化 ---
        function initializeGame() {
            board = JSON.parse(JSON.stringify(initialBoard)); // 盤面をディープコピー
            currentPlayer = 'sente';
            selectedSquare = null;
            senteCaptured = [];
            goteCaptured = [];
            renderBoard();
            renderCapturedPieces();
            updateStatus('対局を開始します。先手の番です。');
            updateCurrentPlayerDisplay();
        }

        // --- 盤面の描画 ---
        function renderBoard() {
            boardElement.innerHTML = ''; // 既存の盤面をクリア

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.dataset.row = r;
                    square.dataset.col = c;

                    const piece = board[r][c];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.classList.add('piece', piece.player);
                        if (PIECES[piece.type] && PIECES[piece.type].char) {
                            pieceElement.textContent = PIECES[piece.type].char;
                        } else {
                            pieceElement.textContent = piece.type; // 未定義の場合も一応表示
                        }

                        // 成り駒の表示クラス
                        if (['と', '成香', '成桂', '成銀', '馬', '龍'].includes(piece.type)) {
                            pieceElement.classList.add('promoted');
                        }
                        square.appendChild(pieceElement);
                    }
                    square.addEventListener('click', handleSquareClick);
                    boardElement.appendChild(square);
                }
            }
        }

        // --- 持ち駒の描画 ---
        function renderCapturedPieces() {
            senteCapturedElement.innerHTML = '';
            goteCapturedElement.innerHTML = '';

            // 先手の持ち駒
            senteCaptured.forEach((pieceType, index) => {
                const pieceElement = document.createElement('span');
                pieceElement.classList.add('captured-piece', 'sente');
                pieceElement.textContent = PIECES[pieceType] ? PIECES[pieceType].char : pieceType;
                pieceElement.dataset.pieceType = pieceType;
                pieceElement.dataset.player = 'sente';
                pieceElement.dataset.index = index; // 持ち駒のインデックス
                pieceElement.addEventListener('click', handleCapturedPieceClick);
                senteCapturedElement.appendChild(pieceElement);
            });

            // 後手の持ち駒
            goteCaptured.forEach((pieceType, index) => {
                const pieceElement = document.createElement('span');
                pieceElement.classList.add('captured-piece', 'gote');
                pieceElement.textContent = PIECES[pieceType] ? PIECES[pieceType].char : pieceType;
                pieceElement.dataset.pieceType = pieceType;
                pieceElement.dataset.player = 'gote';
                pieceElement.dataset.index = index; // 持ち駒のインデックス
                pieceElement.addEventListener('click', handleCapturedPieceClick);
                goteCapturedElement.appendChild(pieceElement);
            });
        }

        // --- ステータス表示の更新 ---
        function updateStatus(message) {
            statusMessageElement.textContent = message;
        }

        // --- 現在の手番表示の更新 ---
        function updateCurrentPlayerDisplay() {
            currentPlayerElement.textContent = `現在の手番: ${currentPlayer === 'sente' ? '先手' : '後手'}`;
            currentPlayerElement.style.color = currentPlayer === 'sente' ? '#d12222' : '#2222d1';
        }

        // --- 盤面クリックハンドラ ---
        function handleSquareClick(event) {
            if (isMoving) return; // アニメーション中は操作不可

            const squareElement = event.currentTarget;
            const row = parseInt(squareElement.dataset.row);
            const col = parseInt(squareElement.dataset.col);
            const piece = board[row][col];

            // 駒が選択されている場合 (移動先を決定)
            if (selectedSquare) {
                const selectedRow = selectedSquare.row;
                const selectedCol = selectedSquare.col;
                const selectedPiece = board[selectedRow][selectedCol];

                // 選択中の駒と同じマスをクリックした場合、選択解除
                if (selectedRow === row && selectedCol === col) {
                    clearSelections();
                    return;
                }

                // 選択中の持ち駒がある場合 (駒を置く処理)
                if (selectedSquare.fromHand) {
                    dropPiece(selectedSquare.type, row, col);
                    clearSelections();
                    return;
                }

                // 選択中の盤上の駒を移動
                if (selectedPiece && selectedPiece.player === currentPlayer) {
                    movePiece(selectedRow, selectedCol, row, col);
                }
                clearSelections();
            }
            // 駒が選択されていない場合 (駒を選択)
            else {
                if (piece && piece.player === currentPlayer) {
                    selectSquare(row, col);
                } else if (piece && piece.player !== currentPlayer) {
                    updateStatus('相手の駒は選択できません。');
                } else {
                    updateStatus('駒がありません。');
                }
            }
        }

        // --- 持ち駒クリックハンドラ ---
        function handleCapturedPieceClick(event) {
            if (isMoving) return;

            const pieceElement = event.currentTarget;
            const pieceType = pieceElement.dataset.pieceType;
            const player = pieceElement.dataset.player;
            const index = parseInt(pieceElement.dataset.index);

            // 現在の手番の持ち駒のみ選択可能
            if (player !== currentPlayer) {
                updateStatus('相手の持ち駒は使用できません。');
                return;
            }

            // 既に選択中の駒がある場合はクリア
            clearSelections();

            // 持ち駒を選択状態にする
            selectedSquare = { type: pieceType, fromHand: true, index: index };
            pieceElement.classList.add('selected'); // 持ち駒にもselectedクラスを適用
            highlightMovableSquaresForDrop(pieceType);
            updateStatus(`${PIECES[pieceType].char} を置く場所を選択してください。`);
        }

        // --- マスの選択 (ハイライト表示) ---
        function selectSquare(row, col) {
            clearSelections(); // 他の選択をクリア
            const square = boardElement.children[row * 9 + col];
            square.classList.add('selected');
            selectedSquare = { row, col };
            highlightMovableSquares(row, col);
            updateStatus(`${PIECES[board[row][col].type].char} を選択しました。移動先を選択してください。`);
        }

        // --- 選択状態のクリア ---
        function clearSelections() {
            document.querySelectorAll('.square.selected, .square.movable, .captured-piece.selected').forEach(el => {
                el.classList.remove('selected', 'movable');
            });
            selectedSquare = null;
        }

        // --- 駒の移動 ---
        async function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;

            const targetPiece = board[toRow][toCol];

            // 選択した駒のプレイヤーと現在の手番が一致しない場合は移動不可
            if (piece.player !== currentPlayer) {
                updateStatus('相手の駒は動かせません。');
                return false;
            }

            // 移動先のマスが自分の駒で占められている場合は移動不可
            if (targetPiece && targetPiece.player === currentPlayer) {
                updateStatus('自分の駒のあるマスには移動できません。');
                return false;
            }

            // 合法手かどうかの判定 (簡易版)
            const isValidMove = checkValidMove(piece, fromRow, fromCol, toRow, toCol);

            if (!isValidMove) {
                updateStatus('その手はルール上指せません。');
                return false;
            }

            // 王手になる移動は許可しない (簡易版)
            // 実際には移動後に王手にならないかチェックする必要があるが、ここでは省略
            // より本格的な実装では、試行的な移動を行い、王手にならないかチェックする

            // 駒を動かすアニメーション
            isMoving = true;
            await animateMove(fromRow, fromCol, toRow, toCol);
            isMoving = false;

            // 敵駒を取る処理
            if (targetPiece && targetPiece.player !== currentPlayer) {
                capturePiece(targetPiece);
            }

            // 盤面を更新
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;

            // 成りの判定
            const originalType = piece.type;
            const canPromote = PIECES[originalType].canPromote;
            const promoteZone = (currentPlayer === 'sente' && (toRow <= 2 || fromRow <= 2)) ||
                                (currentPlayer === 'gote' && (toRow >= 6 || fromRow >= 6));

            // 王と金は成れない、既に成っている駒は成れない
            if (canPromote && promoteZone && !['王', '金', 'と', '成香', '成桂', '成銀', '馬', '龍'].includes(originalType)) {
                // 成るかどうかの確認
                if (confirm('駒を成りますか？')) {
                    piece.type = PROMOTED_MAP[originalType];
                }
            }

            // 強制成りの条件 (歩・香・桂)
            if (originalType === '歩' && ((currentPlayer === 'sente' && toRow === 0) || (currentPlayer === 'gote' && toRow === 8))) {
                piece.type = PROMOTED_MAP[originalType];
            } else if (originalType === '香' && ((currentPlayer === 'sente' && toRow === 0) || (currentPlayer === 'gote' && toRow === 8))) {
                piece.type = PROMOTED_MAP[originalType];
            } else if (originalType === '桂' && ((currentPlayer === 'sente' && (toRow === 0 || toRow === 1)) || (currentPlayer === 'gote' && (toRow === 7 || toRow === 8)))) {
                piece.type = PROMOTED_MAP[originalType];
            }

            renderBoard();
            renderCapturedPieces();

            // 王手判定
            if (isCheck(getOpponentPlayer())) {
                updateStatus(`${currentPlayer === 'sente' ? '先手' : '後手'}が王手！`);
            } else {
                updateStatus(`${currentPlayer === 'sente' ? '先手' : '後手'}が指しました。`);
            }

            // ターンの交代
            switchTurn();
            return true;
        }

        // --- 駒を置く (持ち駒を使う) ---
        function dropPiece(pieceType, toRow, toCol) {
            const targetPiece = board[toRow][toCol];

            // 駒があるマスには置けない
            if (targetPiece) {
                updateStatus('駒のあるマスには置けません。');
                return false;
            }

            // 二歩の判定 (歩を打つ場合のみ)
            if (pieceType === '歩') {
                const pawnInColumn = board.some(row =>
                    row[toCol] && row[toCol].type === '歩' && row[toCol].player === currentPlayer
                );
                if (pawnInColumn) {
                    updateStatus('二歩になる場所には歩を置けません。');
                    return false;
                }
            }

            // 打ち歩詰めの判定 (簡易版)
            // 実際には打ち歩詰めの判定は複雑なので、ここでは省略
            // 王手チェックと合わせて行う必要がある

            // 打ち場所の制限 (桂馬と香車)
            if (pieceType === '桂') {
                if ((currentPlayer === 'sente' && (toRow === 0 || toRow === 1)) ||
                    (currentPlayer === 'gote' && (toRow === 7 || toRow === 8))) {
                    updateStatus('桂馬を置けない場所です。');
                    return false;
                }
            }
            if (pieceType === '香') {
                if ((currentPlayer === 'sente' && toRow === 0) || (currentPlayer === 'gote' && toRow === 8)) {
                    updateStatus('香車を置けない場所です。');
                    return false;
                }
            }

            // 持ち駒から削除
            if (currentPlayer === 'sente') {
                senteCaptured.splice(selectedSquare.index, 1);
            } else {
                goteCaptured.splice(selectedSquare.index, 1);
            }

            // 盤面に駒を配置
            board[toRow][toCol] = { type: pieceType, player: currentPlayer };

            renderBoard();
            renderCapturedPieces();

            // 王手判定
            if (isCheck(getOpponentPlayer())) {
                updateStatus(`${currentPlayer === 'sente' ? '先手' : '後手'}が王手！`);
            } else {
                updateStatus(`${currentPlayer === 'sente' ? '先手' : '後手'}が駒を打ちました。`);
            }

            // ターンの交代
            switchTurn();
            return true;
        }

        // --- 駒を取る ---
        function capturePiece(capturedPiece) {
            // 成り駒の場合は元の駒に戻す
            let originalPieceType = capturedPiece.type;
            if (['と', '成香', '成桂', '成銀', '馬', '龍'].includes(capturedPiece.type)) {
                // 逆引きマップ
                const reversePromotedMap = Object.fromEntries(Object.entries(PROMOTED_MAP).map(([key, value]) => [value, key]));
                originalPieceType = reversePromotedMap[capturedPiece.type];
            }

            if (currentPlayer === 'sente') {
                senteCaptured.push(originalPieceType);
            } else {
                goteCaptured.push(originalPieceType);
            }
            updateStatus(`${currentPlayer === 'sente' ? '先手' : '後手'}が${PIECES[capturedPiece.type].char}を取りました。`);
        }

        // --- ターン交代 ---
        function switchTurn() {
            currentPlayer = currentPlayer === 'sente' ? 'gote' : 'sente';
            updateCurrentPlayerDisplay();
            // AIが有効で、かつAIの番になったらAIの手を指す
            if (isAIEnabled && currentPlayer === 'gote') { // CPUは後手番
                setTimeout(makeCPUMove, 500); // 0.5秒後にCPUの手を指す
            }
        }

        // --- リセットボタン ---
        resetButton.addEventListener('click', initializeGame);

        // --- AI切り替えボタン ---
        aiToggleButton.addEventListener('click', () => {
            isAIEnabled = !isAIEnabled;
            aiToggleButton.textContent = isAIEnabled ? 'AI (CPU) 対戦を無効にする' : 'AI (CPU) 対戦を有効にする';
            aiToggleButton.style.backgroundColor = isAIEnabled ? '#dc3545' : '#28a745';
            if (isAIEnabled && currentPlayer === 'gote') {
                setTimeout(makeCPUMove, 500);
            } else if (!isAIEnabled && currentPlayer === 'gote') {
                updateStatus('CPU対戦が無効になりました。後手番はプレイヤーが操作してください。');
            }
        });

        // --- 駒の移動アニメーション ---
        function animateMove(fromRow, fromCol, toRow, toCol) {
            return new Promise(resolve => {
                const fromSquare = boardElement.children[fromRow * 9 + fromCol];
                const toSquare = boardElement.children[toRow * 9 + toCol];
                const pieceElement = fromSquare.querySelector('.piece');

                if (!pieceElement) {
                    resolve();
                    return;
                }

                // 移動元と移動先の位置を計算
                const fromRect = fromSquare.getBoundingClientRect();
                const toRect = toSquare.getBoundingClientRect();
                const boardRect = boardElement.getBoundingClientRect();

                // 盤面内の相対位置
                const dx = (toRect.left - fromRect.left);
                const dy = (toRect.top - fromRect.top);

                // アニメーション用のダミー要素を作成
                const movingPiece = pieceElement.cloneNode(true);
                movingPiece.style.position = 'absolute';
                movingPiece.style.left = `${fromRect.left - boardRect.left}px`;
                movingPiece.style.top = `${fromRect.top - boardRect.top}px`;
                movingPiece.style.zIndex = 100;
                movingPiece.style.transition = 'transform 0.3s ease-out';
                boardElement.appendChild(movingPiece);

                // 元の駒を非表示にする
                pieceElement.style.opacity = '0';

                // アニメーション実行
                requestAnimationFrame(() => {
                    movingPiece.style.transform = `translate(${dx}px, ${dy}px)`;
                });

                // アニメーション終了後に処理
                movingPiece.addEventListener('transitionend', () => {
                    boardElement.removeChild(movingPiece);
                    pieceElement.style.opacity = '1'; // 元の駒を再表示
                    resolve();
                }, { once: true });
            });
        }


        // --- 合法手の取得 (非常に簡易的) ---
        function getMovableSquares(piece, row, col) {
            const moves = [];
            const d = piece.player === 'sente' ? -1 : 1; // 先手は上方向、後手は下方向

            switch (piece.type) {
                case '歩':
                    // 前1マス
                    if (isValidPos(row + d, col) && !board[row + d][col]) {
                        moves.push({ r: row + d, c: col });
                    }
                    // 駒取り
                    if (isValidPos(row + d, col) && board[row + d][col] && board[row + d][col].player !== piece.player) {
                        moves.push({ r: row + d, c: col });
                    }
                    break;
                case '香':
                    // 縦方向にどこまでも
                    for (let r = row + d; isValidPos(r, col); r += d) {
                        if (!board[r][col]) {
                            moves.push({ r, c: col });
                        } else {
                            if (board[r][col].player !== piece.player) {
                                moves.push({ r, c: col }); // 敵駒を取る
                            }
                            break; // 駒にぶつかったら止まる
                        }
                    }
                    break;
                case '桂':
                    // 桂馬跳び (2マス進んで左右1マス)
                    const knightMoves = [
                        { dr: 2 * d, dc: -1 },
                        { dr: 2 * d, dc: 1 }
                    ];
                    knightMoves.forEach(move => {
                        const newR = row + move.dr;
                        const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!board[newR][newC] || board[newR][newC].player !== piece.player)) {
                            moves.push({ r: newR, c: newC });
                        }
                    });
                    break;
                case '銀':
                    const silverMoves = [
                        { dr: d, dc: 0 },   // 前
                        { dr: d, dc: -1 },  // 左斜め前
                        { dr: d, dc: 1 },   // 右斜め前
                        { dr: -d, dc: -1 }, // 左斜め後 (逆方向)
                        { dr: -d, dc: 1 }   // 右斜め後 (逆方向)
                    ];
                    silverMoves.forEach(move => {
                        const newR = row + move.dr;
                        const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!board[newR][newC] || board[newR][newC].player !== piece.player)) {
                            moves.push({ r: newR, c: newC });
                        }
                    });
                    break;
                case '金': // 金と成駒は同じ動き
                case 'と':
                case '成香':
                case '成桂':
                case '成銀':
                    const goldMoves = [
                        { dr: d, dc: 0 },   // 前
                        { dr: d, dc: -1 },  // 左斜め前
                        { dr: d, dc: 1 },   // 右斜め前
                        { dr: 0, dc: -1 },  // 左
                        { dr: 0, dc: 1 },   // 右
                        { dr: -d, dc: 0 }   // 後ろ
                    ];
                    goldMoves.forEach(move => {
                        const newR = row + move.dr;
                        const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!board[newR][newC] || board[newR][newC].player !== piece.player)) {
                            moves.push({ r: newR, c: newC });
                        }
                    });
                    break;
                case '角':
                    // 斜め方向にどこまでも
                    const bishopDirections = [[d, d], [d, -d], [-d, d], [-d, -d]]; // 全ての斜め方向
                    bishopDirections.forEach(([dr, dc]) => {
                        for (let i = 1; ; i++) {
                            const newR = row + dr * i;
                            const newC = col + dc * i;
                            if (!isValidPos(newR, newC)) break;
                            if (!board[newR][newC]) {
                                moves.push({ r: newR, c: newC });
                            } else {
                                if (board[newR][newC].player !== piece.player) {
                                    moves.push({ r: newR, c: newC });
                                }
                                break;
                            }
                        }
                    });
                    break;
                case '飛':
                    // 縦横にどこまでも
                    const rookDirections = [[d, 0], [-d, 0], [0, d], [0, -d]]; // 全ての縦横方向
                    rookDirections.forEach(([dr, dc]) => {
                        for (let i = 1; ; i++) {
                            const newR = row + dr * i;
                            const newC = col + dc * i;
                            if (!isValidPos(newR, newC)) break;
                            if (!board[newR][newC]) {
                                moves.push({ r: newR, c: newC });
                            } else {
                                if (board[newR][newC].player !== piece.player) {
                                    moves.push({ r: newR, c: newC });
                                }
                                break;
                            }
                        }
                    });
                    break;
                case '王':
                    // 全方向に1マス
                    const kingMoves = [
                        { dr: d, dc: 0 }, { dr: d, dc: -1 }, { dr: d, dc: 1 },
                        { dr: 0, dc: -1 }, { dr: 0, dc: 1 },
                        { dr: -d, dc: 0 }, { dr: -d, dc: -1 }, { dr: -d, dc: 1 }
                    ];
                    kingMoves.forEach(move => {
                        const newR = row + move.dr;
                        const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!board[newR][newC] || board[newR][newC].player !== piece.player)) {
                            moves.push({ r: newR, c: newC });
                        }
                    });
                    break;
                case '馬': // 成り角の動き (角の動き + 王の動き)
                    // 角の動き
                    const horseBishopDirections = [[d, d], [d, -d], [-d, d], [-d, -d]];
                    horseBishopDirections.forEach(([dr, dc]) => {
                        for (let i = 1; ; i++) {
                            const newR = row + dr * i;
                            const newC = col + dc * i;
                            if (!isValidPos(newR, newC)) break;
                            if (!board[newR][newC]) {
                                moves.push({ r: newR, c: newC });
                            } else {
                                if (board[newR][newC].player !== piece.player) {
                                    moves.push({ r: newR, c: newC });
                                }
                                break;
                            }
                        }
                    });
                    // 王の動き
                    const horseKingMoves = [
                        { dr: d, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }, { dr: -d, dc: 0 }
                    ]; // 王の直線移動部分 (斜めは角でカバー)
                    horseKingMoves.forEach(move => {
                        const newR = row + move.dr;
                        const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!board[newR][newC] || board[newR][newC].player !== piece.player)) {
                            moves.push({ r: newR, c: newC });
                        }
                    });
                    break;
                case '龍': // 成り飛車の動き (飛車の動き + 王の斜め移動)
                    // 飛車の動き
                    const dragonRookDirections = [[d, 0], [-d, 0], [0, d], [0, -d]];
                    dragonRookDirections.forEach(([dr, dc]) => {
                        for (let i = 1; ; i++) {
                            const newR = row + dr * i;
                            const newC = col + dc * i;
                            if (!isValidPos(newR, newC)) break;
                            if (!board[newR][newC]) {
                                moves.push({ r: newR, c: newC });
                            } else {
                                if (board[newR][newC].player !== piece.player) {
                                    moves.push({ r: newR, c: newC });
                                }
                                break;
                            }
                        }
                    });
                    // 王の斜め移動
                    const dragonKingMoves = [
                        { dr: d, dc: -1 }, { dr: d, dc: 1 }, { dr: -d, dc: -1 }, { dr: -d, dc: 1 }
                    ]; // 王の斜め移動部分 (直線は飛車でカバー)
                    dragonKingMoves.forEach(move => {
                        const newR = row + move.dr;
                        const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!board[newR][newC] || board[newR][newC].player !== piece.player)) {
                            moves.push({ r: newR, c: newC });
                        }
                    });
                    break;
            }
            return moves;
        }

        // --- 駒の移動が可能かハイライト表示 ---
        function highlightMovableSquares(row, col) {
            const piece = board[row][col];
            if (!piece) return;

            const movableSquares = getMovableSquares(piece, row, col);
            movableSquares.forEach(move => {
                const targetSquare = boardElement.children[move.r * 9 + move.c];
                targetSquare.classList.add('movable');
            });
        }

        // --- 持ち駒を置く場所のハイライト表示 ---
        function highlightMovableSquaresForDrop(pieceType) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    // 駒がないマスのみ
                    if (!board[r][c]) {
                        // 二歩チェック (歩の場合)
                        if (pieceType === '歩') {
                            const pawnInColumn = board.some(row =>
                                row[c] && row[c].type === '歩' && row[c].player === currentPlayer
                            );
                            if (pawnInColumn) continue; // 二歩になるならスキップ
                        }
                        // 打ち場所の制限 (桂馬と香車)
                        if (pieceType === '桂') {
                            if ((currentPlayer === 'sente' && (r === 0 || r === 1)) ||
                                (currentPlayer === 'gote' && (r === 7 || r === 8))) {
                                continue;
                            }
                        }
                        if (pieceType === '香') {
                            if ((currentPlayer === 'sente' && r === 0) || (currentPlayer === 'gote' && r === 8)) {
                                continue;
                            }
                        }
                        // ここで王手にならないかチェックするべきだが、簡易版のため省略
                        const targetSquare = boardElement.children[r * 9 + c];
                        targetSquare.classList.add('movable');
                    }
                }
            }
        }


        // --- 移動が合法手かチェック (getMovableSquaresの結果に含まれるか) ---
        function checkValidMove(piece, fromR, fromC, toR, toC) {
            const movableSquares = getMovableSquares(piece, fromR, fromC);
            return movableSquares.some(move => move.r === toR && move.c === toC);
        }

        // --- 有効な盤面座標か判定 ---
        function isValidPos(r, c) {
            return r >= 0 && r < 9 && c >= 0 && c < 9;
        }

        // --- 王手判定 (簡易版) ---
        function isCheck(player) {
            const opponent = getOpponentPlayer(player);
            let kingPos = null;

            // 相手の王の位置を探す
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = board[r][c];
                    if (piece && piece.type === '王' && piece.player === player) {
                        kingPos = { r, c };
                        break;
                    }
                }
                if (kingPos) break;
            }

            if (!kingPos) return false; // 王がいない場合（エラーケース）

            // 相手の全ての駒について、王手になるかチェック
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === opponent) {
                        const possibleMoves = getMovableSquares(piece, r, c);
                        // 可能な移動先に王のマスが含まれているか
                        if (possibleMoves.some(move => move.r === kingPos.r && move.c === kingPos.c)) {
                            return true; // 王手
                        }
                    }
                }
            }
            return false; // 王手ではない
        }

        // --- 相手プレイヤーを取得 ---
        function getOpponentPlayer(player = currentPlayer) {
            return player === 'sente' ? 'gote' : 'sente';
        }

        // --- CPU (AI) の手番処理 ---
        async function makeCPUMove() {
            updateStatus('CPUが思考中です...');
            await new Promise(resolve => setTimeout(resolve, 1000)); // 思考をシミュレート

            const possibleMoves = getAllPossibleMoves(currentPlayer);

            if (possibleMoves.length === 0) {
                updateStatus('CPUは指す手がありません。（詰み）');
                return;
            }

            // --- 簡易AIロジック ---
            // 1. 王手になる手があれば優先 (相手を詰める方向)
            // 2. 相手の駒を取れる手があれば優先
            // 3. ランダムな手を選択

            let bestMove = null;
            let bestScore = -Infinity; // より良い手を探すためのスコア

            // 駒の価値 (簡易的なもの)
            const pieceValues = {
                '歩': 100, '香': 200, '桂': 300, '銀': 400, '金': 500,
                '角': 800, '飛': 1000, '王': Infinity,
                'と': 400, '成香': 400, '成桂': 400, '成銀': 400, '馬': 1000, '龍': 1200
            };

            for (const move of possibleMoves) {
                let currentScore = 0;
                // 仮想的に手を指してみる
                const tempBoard = JSON.parse(JSON.stringify(board));
                const tempSenteCaptured = [...senteCaptured];
                const tempGoteCaptured = [...goteCaptured];

                let capturedPieceType = null;

                if (move.type === 'move') {
                    const piece = tempBoard[move.fromR][move.fromC];
                    const targetPiece = tempBoard[move.toR][move.toC];

                    if (targetPiece && targetPiece.player !== currentPlayer) {
                        capturedPieceType = targetPiece.type;
                        currentScore += pieceValues[capturedPieceType] || 0; // 取る駒の価値を加算
                    }
                    tempBoard[move.toR][move.toC] = piece;
                    tempBoard[move.fromR][move.fromC] = null;

                    // 成りのシミュレート (強制成りだけ考慮)
                    if (piece.type === '歩' && ((currentPlayer === 'sente' && move.toR === 0) || (currentPlayer === 'gote' && move.toR === 8))) {
                        piece.type = PROMOTED_MAP[piece.type];
                    } else if (piece.type === '香' && ((currentPlayer === 'sente' && move.toR === 0) || (currentPlayer === 'gote' && move.toR === 8))) {
                        piece.type = PROMOTED_MAP[piece.type];
                    } else if (piece.type === '桂' && ((currentPlayer === 'sente' && (move.toR === 0 || move.toR === 1)) || (currentPlayer === 'gote' && (move.toR === 7 || move.toR === 8)))) {
                        piece.type = PROMOTED_MAP[piece.type];
                    }

                } else if (move.type === 'drop') {
                    tempBoard[move.toR][move.toC] = { type: move.pieceType, player: currentPlayer };
                }

                // 移動後の王手判定
                if (isCheckTemp(getOpponentPlayer(), tempBoard)) {
                    currentScore += 10000; // 王手になる手は高評価
                }

                if (currentScore > bestScore) {
                    bestScore = currentScore;
                    bestMove = move;
                }
            }

            // 最善手が見つからない場合、ランダムに選択
            if (!bestMove) {
                bestMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            }


            // 実際に手を指す
            if (bestMove.type === 'move') {
                await movePiece(bestMove.fromR, bestMove.fromC, bestMove.toR, bestMove.toC);
            } else if (bestMove.type === 'drop') {
                // 持ち駒のインデックスを再取得 (現在の配列から)
                let dropIndex;
                if (currentPlayer === 'sente') {
                    dropIndex = senteCaptured.findIndex(p => p === bestMove.pieceType);
                } else {
                    dropIndex = goteCaptured.findIndex(p => p === bestMove.pieceType);
                }
                if (dropIndex !== -1) {
                    selectedSquare = { type: bestMove.pieceType, fromHand: true, index: dropIndex };
                    await dropPiece(bestMove.pieceType, bestMove.toR, bestMove.toC);
                }
            }
            clearSelections();
            updateStatus('CPUが指しました。次の手番です。');
        }

        // --- 全ての合法手の取得 ---
        function getAllPossibleMoves(player) {
            const moves = [];

            // 盤上からの移動
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = board[r][c];
                    if (piece && piece.player === player) {
                        const movableSquares = getMovableSquares(piece, r, c);
                        movableSquares.forEach(move => {
                            // 王手になる手は除外 (簡易版では移動後の王手判定は省略)
                            // ここで仮想的に移動して、isCheck(currentPlayer) がtrueになるなら除外
                            // ...
                            moves.push({ type: 'move', fromR: r, fromC: c, toR: move.r, toC: move.c, piece: piece.type });
                        });
                    }
                }
            }

            // 持ち駒を打つ手
            const capturedPieces = player === 'sente' ? senteCaptured : goteCaptured;
            const uniqueCapturedPieces = [...new Set(capturedPieces)]; // 重複を排除

            uniqueCapturedPieces.forEach(pieceType => {
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (!board[r][c]) {
                            // 二歩チェック
                            if (pieceType === '歩') {
                                const pawnInColumn = board.some(row =>
                                    row[c] && row[c].type === '歩' && row[c].player === player
                                );
                                if (pawnInColumn) continue;
                            }
                            // 打ち場所制限 (桂馬、香車)
                            if (pieceType === '桂') {
                                if ((player === 'sente' && (r === 0 || r === 1)) ||
                                    (player === 'gote' && (r === 7 || r === 8))) {
                                    continue;
                                }
                            }
                            if (pieceType === '香') {
                                if ((player === 'sente' && r === 0) || (player === 'gote' && r === 8)) {
                                    continue;
                                }
                            }
                            // 打ち歩詰めチェック (簡易版では省略)
                            // ...

                            moves.push({ type: 'drop', pieceType: pieceType, toR: r, toC: c });
                        }
                    }
                }
            });

            return moves;
        }

        // --- 仮想ボードでの王手判定 (CPU思考用) ---
        function isCheckTemp(player, tempBoard) {
            const opponent = getOpponentPlayer(player);
            let kingPos = null;

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = tempBoard[r][c];
                    if (piece && piece.type === '王' && piece.player === player) {
                        kingPos = { r, c };
                        break;
                    }
                }
                if (kingPos) break;
            }

            if (!kingPos) return false;

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = tempBoard[r][c];
                    if (piece && piece.player === opponent) {
                        // 仮想ボードでの駒の動きを取得
                        const possibleMoves = getMovableSquaresTemp(piece, r, c, tempBoard);
                        if (possibleMoves.some(move => move.r === kingPos.r && move.c === kingPos.c)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // --- 仮想ボード用 getMovableSquares (tempBoard を引数に追加) ---
        function getMovableSquaresTemp(piece, row, col, currentBoard) {
            const moves = [];
            const d = piece.player === 'sente' ? -1 : 1; // 先手は上方向、後手は下方向

            switch (piece.type) {
                case '歩':
                    if (isValidPos(row + d, col)) {
                        if (!currentBoard[row + d][col]) moves.push({ r: row + d, c: col });
                        else if (currentBoard[row + d][col].player !== piece.player) moves.push({ r: row + d, c: col });
                    }
                    break;
                case '香':
                    for (let r_ = row + d; isValidPos(r_, col); r_ += d) {
                        if (!currentBoard[r_][col]) moves.push({ r: r_, c: col });
                        else { if (currentBoard[r_][col].player !== piece.player) moves.push({ r: r_, c: col }); break; }
                    }
                    break;
                case '桂':
                    const knightMoves = [{ dr: 2 * d, dc: -1 }, { dr: 2 * d, dc: 1 }];
                    knightMoves.forEach(move => {
                        const newR = row + move.dr; const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!currentBoard[newR][newC] || currentBoard[newR][newC].player !== piece.player)) moves.push({ r: newR, c: newC });
                    });
                    break;
                case '銀':
                    const silverMoves = [{ dr: d, dc: 0 }, { dr: d, dc: -1 }, { dr: d, dc: 1 }, { dr: -d, dc: -1 }, { dr: -d, dc: 1 }];
                    silverMoves.forEach(move => {
                        const newR = row + move.dr; const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!currentBoard[newR][newC] || currentBoard[newR][newC].player !== piece.player)) moves.push({ r: newR, c: newC });
                    });
                    break;
                case '金': case 'と': case '成香': case '成桂': case '成銀':
                    const goldMoves = [{ dr: d, dc: 0 }, { dr: d, dc: -1 }, { dr: d, dc: 1 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }, { dr: -d, dc: 0 }];
                    goldMoves.forEach(move => {
                        const newR = row + move.dr; const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!currentBoard[newR][newC] || currentBoard[newR][newC].player !== piece.player)) moves.push({ r: newR, c: newC });
                    });
                    break;
                case '角':
                    const bishopDirections = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                    bishopDirections.forEach(([dr, dc]) => {
                        for (let i = 1; ; i++) {
                            const newR = row + dr * i; const newC = col + dc * i;
                            if (!isValidPos(newR, newC)) break;
                            if (!currentBoard[newR][newC]) moves.push({ r: newR, c: newC });
                            else { if (currentBoard[newR][newC].player !== piece.player) moves.push({ r: newR, c: newC }); break; }
                        }
                    });
                    break;
                case '飛':
                    const rookDirections = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                    rookDirections.forEach(([dr, dc]) => {
                        for (let i = 1; ; i++) {
                            const newR = row + dr * i; const newC = col + dc * i;
                            if (!isValidPos(newR, newC)) break;
                            if (!currentBoard[newR][newC]) moves.push({ r: newR, c: newC });
                            else { if (currentBoard[newR][newC].player !== piece.player) moves.push({ r: newR, c: newC }); break; }
                        }
                    });
                    break;
                case '王':
                    const kingMoves = [[1, 0], [1, -1], [1, 1], [0, -1], [0, 1], [-1, 0], [-1, -1], [-1, 1]];
                    kingMoves.forEach(move => {
                        const newR = row + move.dr; const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!currentBoard[newR][newC] || currentBoard[newR][newC].player !== piece.player)) moves.push({ r: newR, c: newC });
                    });
                    break;
                case '馬':
                    const horseBishopDirections = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                    horseBishopDirections.forEach(([dr, dc]) => {
                        for (let i = 1; ; i++) {
                            const newR = row + dr * i; const newC = col + dc * i;
                            if (!isValidPos(newR, newC)) break;
                            if (!currentBoard[newR][newC]) moves.push({ r: newR, c: newC });
                            else { if (currentBoard[newR][newC].player !== piece.player) moves.push({ r: newR, c: newC }); break; }
                        }
                    });
                    const horseKingMoves = [[1, 0], [0, -1], [0, 1], [-1, 0]];
                    horseKingMoves.forEach(move => {
                        const newR = row + move.dr; const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!currentBoard[newR][newC] || currentBoard[newR][newC].player !== piece.player)) moves.push({ r: newR, c: newC });
                    });
                    break;
                case '龍':
                    const dragonRookDirections = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                    dragonRookDirections.forEach(([dr, dc]) => {
                        for (let i = 1; ; i++) {
                            const newR = row + dr * i; const newC = col + dc * i;
                            if (!isValidPos(newR, newC)) break;
                            if (!currentBoard[newR][newC]) moves.push({ r: newR, c: newC });
                            else { if (currentBoard[newR][newC].player !== piece.player) moves.push({ r: newR, c: newC }); break; }
                        }
                    });
                    const dragonKingMoves = [[1, -1], [1, 1], [-1, -1], [-1, 1]];
                    dragonKingMoves.forEach(move => {
                        const newR = row + move.dr; const newC = col + move.dc;
                        if (isValidPos(newR, newC) && (!currentBoard[newR][newC] || currentBoard[newR][newC].player !== piece.player)) moves.push({ r: newR, c: newC });
                    });
                    break;
            }
            return moves;
        }

        // 初期化
        initializeGame();
    </script>
</body>
</html>
